<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat with GPT-3.5-turbo</title>
</head>
<body>
    <h1>Chat with GPT-3.5-turbo</h1>

    <div id="messages">
    
    </div>
    
    <input type="hidden" id="ai_id" value="{{ ai_id }}">
    <input type="hidden" id="ai_name" value="{{ ai_name }}">

    <form id="user_message_form" method="POST">
        <input type="hidden" name="messages" value="{{ messages }}">
        <label for="user_message">Your message:</label>
        <input type="text" name="user_message" id="user_message" autofocus>
        <label for="experience_space">Experience Space:</label>
        <select name="experience_space" id="experience_space">
            {% for es in all_experience_spaces %}
                <option value="{{ es }}" {% if es == experience_space %}selected{% endif %}>{{ es }}</option>
            {% endfor %}
            <option value="{{ highest_experience_space + 1 }}">Create New Experience Space ({{ highest_experience_space + 1 }})</option>
        </select>
        
        <button type="submit">Send</button>
    </form>

    <form action="{{ url_for('chat') }}" method="POST">
        <input type="hidden" name="messages" value="{{ messages }}">
        <input type="hidden" name="experience_space" id="generate_experience_space" value="{{ experience_space }}">
        <input type="hidden" name="generate_model_message" value="true">
        <button type="submit">Generate Model Message</button>

        <!-- Model Communication Modes -->           
        
        <input type="radio" id="continuous_option" name="response_option" value="continuous" {% if response_option == 'continuous' %}checked{% endif %}>
        <label for="continuous_option">Continuous</label>
        
        <input type="radio" id="thinking_option" name="response_option" value="thinking" {% if response_option == 'thinking' %}checked{% endif %}>
        <label for="thinking_option">Thinking</label>
        
        <input type="radio" id="step_by_step_option" name="response_option" value="step_by_step" {% if response_option == 'step_by_step' %}checked{% endif %}>               
        <label for="step_by_step_option">Step-by-Step</label>
    </form>

    <br />
    <br />
    <div>
        <h3>Token Information:</h3>
        <p><strong>Prompt tokens:</strong> <span id="prompt_tokens">{{ prompt_tokens }}</span></p>
        <p><strong>Completion tokens:</strong> <span id="completion_tokens">{{ completion_tokens }}</span></p>
        <p><strong>Total tokens:</strong> <span id="total_tokens">{{ total_tokens }}</span></p>
    </div>
            
    <input type="hidden" id="initial_messages" value="{{ initial_messages | tojson }}">

    <script>
        /*document.addEventListener("DOMContentLoaded", function () {
            const initialExperienceSpace = document.getElementById("experience_space").value;
            fetchAndUpdateMessages(initialExperienceSpace);
        }); */
        
        document.getElementById("experience_space").addEventListener("change", function () {
            const experienceSpace = this.options[this.selectedIndex].value;
            console.log('experience space passed to fetchAndUpdateMessages:', experienceSpace);
            fetchAndUpdateMessages(experienceSpace);
            document.getElementById("generate_experience_space").value = experienceSpace;
        });   

        document.getElementById("user_message_form").addEventListener("submit", function (event) {
            event.preventDefault();
            const userMessageInput = document.getElementById("user_message");
            const userMessage = userMessageInput.value;
            const experienceSpace = document.getElementById("experience_space").value;
        
            // Send the user message to the server using an AJAX request
            const xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function () {
                if (xhr.readyState === 4) {
                    if (xhr.status === 200) {
                        const response = JSON.parse(xhr.responseText);
                        updateMessages([response.user_message, response.assistant_message], true);
                        userMessageInput.value = ""; // Clear the input field
                        updateTokenInformation(response.usage); // Update the usage values

                        if (response.send_model_message_again) {
                            generateModelMessage(); // Generate the model message again
                        }                        
                    } else {
                        console.error("An error occurred while sending the user message.");
                    }
                }
            };
            xhr.open("POST", "{{ url_for('send_user_message') }}", true);
            xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
            xhr.send(`user_message=${encodeURIComponent(userMessage)}&experience_space=${encodeURIComponent(experienceSpace)}`);
        });      
        
        document.querySelector("form[action='{{ url_for('chat') }}']").addEventListener("submit", function (event) {
            event.preventDefault();                                               
        
            generateModelMessage(); // Call the function to generate a model message
        });
        
        // Model communication modes
        document.getElementById("thinking_option").addEventListener("change", function () {
            updateResponseOption("thinking");
        });
        
        document.getElementById("step_by_step_option").addEventListener("change", function () {
            updateResponseOption("step_by_step");
        });    

        document.getElementById("continuous_option").addEventListener("change", function () {
            updateResponseOption("continuous");
        });   
        
        // Function to send the request to generate a model message using an AJAX request
        function generateModelMessage() {
            const experienceSpace = document.getElementById("experience_space").value; 
            
            const xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function () {
                if (xhr.readyState === 4) {
                    if (xhr.status === 200) {
                        const response = JSON.parse(xhr.responseText);
                        updateMessages([response.assistant_message], true);
                        updateTokenInformation(response.usage); // Update the usage values
                        
                        if (response.send_model_message_again) {
                            generateModelMessage(); // Generate the model message again
                        }
                    } else {
                        console.error("An error occurred while generating the model message.");
                    }
                }
            };
            xhr.open("POST", "{{ url_for('generate_model_message') }}", true);
            xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
            xhr.send(`experience_space=${encodeURIComponent(experienceSpace)}`);
        }
        
                                             
    
        function updateMessages(newMessages, append = false) {
            const messagesDiv = document.getElementById("messages");
            if (!append) {
                messagesDiv.innerHTML = "";
            }
        
            newMessages.forEach(function(message) {
                content = message.content
                const role = message.role.charAt(0).toUpperCase() + message.role.slice(1);
                if(message.role.toLowerCase() !== "system"){
                    content = typeof message.content === "string" ? JSON.parse(message.content) : message.content;
                }
        
                let messageContent = "";
                if (message.role.toLowerCase() === "user" && 'user_name' in content && 'user_message' in content) {
                    let userMessage = {[content.user_name]: content.user_message};
                    if ('memories' in content) {
                        userMessage["memories"] = content.memories;
                    }
                    messageContent = JSON.stringify(userMessage, null, 4);
                } else if (message.role.toLowerCase() === "system") {
                    messageContent = message.content;
                } else {
                    messageContent = JSON.stringify(content, null, 4);
                }

                // Replace newline characters with HTML line breaks
                //messageContent = messageContent.replace(/\n/g, '<br>');
        
                const messageHtml = `<pre><strong>${role}:</strong>${messageContent}</pre>`;
                messagesDiv.innerHTML += messageHtml;
            });
        }
        
        
        
        

        function updateTokenInformation(usage) {
            document.getElementById("prompt_tokens").innerText = usage.prompt_tokens;
            document.getElementById("completion_tokens").innerText = usage.completion_tokens;
            document.getElementById("total_tokens").innerText = usage.total_tokens;
        }

        function updateSelectOptions(newOptions) {
            const select = document.getElementById("experience_space");
            select.innerHTML = "";
            
            newOptions.forEach(function(optionValue) {
                console.log(optionValue)
                const option = document.createElement("option");
                option.value = optionValue;
                option.text = optionValue;
                select.add(option);
            });
        
            // Add "Create New Experience Space" option
            const createNewOption = document.createElement("option");
            createNewOption.value = newOptions[newOptions.length - 1] + 1;
            createNewOption.text = "Create New Experience Space (" + createNewOption.value + ")";
            select.add(createNewOption);
        }
        
        function fetchAndUpdateMessages(experienceSpace) {
            console.log("fetchAndUpdateMessages called with experienceSpace:", experienceSpace);  // Add this line
            const xhr = new XMLHttpRequest();
        
            xhr.onreadystatechange = function () {
                if (xhr.readyState === 4) {
                    if (xhr.status === 200) {
                        const response = JSON.parse(xhr.responseText);
                        updateMessages(response.messages);
                        updateTokenInformation(response.usage);
                        updateSelectOptions(response.all_experience_spaces);
                        document.getElementById("experience_space").value = experienceSpace;
                    } else {
                        console.error("An error occurred while fetching messages.");
                    }
                }
            };
        
            xhr.open("POST", "{{ url_for('change_experience_space') }}", true);
            xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
            xhr.send("experience_space=" + encodeURIComponent(experienceSpace));

        }

        function updateResponseOption(responseOption) {
            const xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function () {
                if (xhr.readyState === 4) {
                    if (xhr.status === 200) {
                        console.log("Response option updated:", responseOption);
                    } else {
                        console.error("An error occurred while updating response option.");
                    }
                }
            };
            xhr.open("POST", "{{ url_for('update_response_option') }}", true);
            xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
            xhr.send("response_option=" + encodeURIComponent(responseOption));
        }        
        
        
        (function () {
            const initialMessagesJson = document.getElementById("initial_messages").value;
            const initialMessages = JSON.parse(initialMessagesJson);
            updateMessages(initialMessages);
        })();        
        
               

    </script>
    
</body>
</html>
